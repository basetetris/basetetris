<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Base Tetris</title>
<style>
:root{
  --bg:#120022;
  --panel:#1a1230;
  --accent1:#ff77ff;
  --accent2:#7be0ff;
  --accent3:#ffd87a;
  --glass: rgba(255,255,255,0.03);
  --card: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
  font-family: 'Segoe UI', Roboto, "Helvetica Neue", Arial, sans-serif;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#1a0820,#070014);color:#e9d7ff}
.app{max-width:1100px;margin:18px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);display:grid;grid-template-columns:1fr 320px;gap:18px}
@media(max-width:960px){.app{grid-template-columns:1fr}}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:6px}
.brand{display:flex;align-items:center;gap:12px}
.logo{width:56px;height:56px;border-radius:10px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:800;color:#1a0122;box-shadow:0 10px 30px rgba(123,224,255,0.06)}
.title{font-size:20px}
.controls{display:flex;gap:8px;align-items:center}
.btn{background:var(--panel);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;color:var(--accent2);cursor:pointer;font-weight:700;transition:all 0.2s ease;}
.btn:hover{background:rgba(255,255,255,0.05);transform:translateY(-2px);}
.small{font-size:13px;color:#d7c7ff}
.panel{background:var(--card);border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03)}
.play-area{display:flex;gap:18px;align-items:flex-start;justify-content:center}
.canvas-wrap{background:linear-gradient(180deg, rgba(0,0,0,0.35), rgba(255,255,255,0.01));padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:inset 0 1px 0 rgba(255,255,255,0.02);position:relative;}
#board{background:#05020a;display:block;border-radius:6px}

/* side info */
.side{display:flex;flex-direction:column;gap:12px}
.info-card{padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))}
.preview-grid{display:flex;gap:8px;flex-direction:column;align-items:center}
.preview-canvas{width:88px;height:64px;background:#05020a;border-radius:8px;border:1px solid rgba(255,255,255,0.03);display:block}

/* vaporwave palette for tetrominoes */
.cell{width:28px;height:28px;border-radius:4px;box-shadow:0 6px 18px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.06)}
.cI{background:linear-gradient(180deg,#ffafff,#ff77ff);border:1px solid rgba(0,0,0,0.2)}
.cO{background:linear-gradient(180deg,#fff1a8,#ffd87a);border:1px solid rgba(0,0,0,0.2)}
.cT{background:linear-gradient(180deg,#c0b0ff,#8f77ff);border:1px solid rgba(0,0,0,0.2)}
.cS{background:linear-gradient(180deg,#a8fff7,#7be0ff);border:1px solid rgba(0,0,0,0.2)}
.cZ{background:linear-gradient(180deg,#ff9bb0,#ff6688);border:1px solid rgba(0,0,0,0.2)}
.cJ{background:linear-gradient(180deg,#9be6ff,#4fc0ff);border:1px solid rgba(0,0,0,0.2)}
.cL{background:linear-gradient(180deg,#ffd6ff,#ff9bff);border:1px solid rgba(0,0,0,0.2)}

/* ghost style */
.ghost{opacity:0.22;filter:blur(0.2px);}

/* footer */
.footer{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:#cdb9ff;font-size:13px}

/* leaderboard list */
.lb-row{display:flex;justify-content:space-between;padding:8px;border-radius:8px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));border:1px solid rgba(255,255,255,0.02);font-weight:700;transition:all 0.2s ease;}
.lb-row:hover{background:linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));}

/* legend */
.legend{display:flex;gap:8px;flex-wrap:wrap}
.legend .item{display:flex;gap:6px;align-items:center;padding:6px 8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));border:1px solid rgba(255,255,255,0.02)}

kbd{background:#14041a;padding:4px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-weight:800;color:var(--accent1)}

/* Mobile responsive styles */
@media (max-width: 768px) {
  .app { padding: 12px; gap: 12px; }
  .play-area { flex-direction: column; align-items: center; }
  .side { width: 100%; }
  .canvas-wrap { width: 100%; display: flex; justify-content: center; }
  #board { width: 100%; max-width: 280px; height: auto; }
  .header { flex-direction: column; align-items: flex-start; }
  .controls { width: 100%; justify-content: space-between; }
  .btn { flex: 1; text-align: center; }
}

/* Game over modal */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 100;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: var(--panel);
  padding: 24px;
  border-radius: 12px;
  max-width: 400px;
  width: 90%;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
}

.modal h2 {
  margin-top: 0;
  color: var(--accent1);
}

.modal input {
  width: 100%;
  padding: 10px;
  margin: 15px 0;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  color: white;
  font-size: 16px;
}

.modal-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
}

/* Instructions panel */
.instructions {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid rgba(255, 255, 255, 0.05);
}

.instructions p {
  margin: 8px 0;
  font-size: 13px;
  color: #cdb9ff;
}

/* Score animations */
.score-update {
  animation: pulse 0.5s ease;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

/* Line clear animation */
.line-clear {
  animation: clearLine 0.3s ease;
}

@keyframes clearLine {
  0% { background: rgba(255, 255, 255, 0.1); }
  50% { background: rgba(255, 255, 255, 0.3); }
  100% { background: transparent; }
}

/* Difficulty selector */
.difficulty {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.difficulty-btn {
  flex: 1;
  padding: 6px;
  font-size: 12px;
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 6px;
  color: #d7c7ff;
  cursor: pointer;
  transition: all 0.2s ease;
}

.difficulty-btn.active {
  background: var(--accent2);
  color: #1a0122;
  font-weight: bold;
}

/* Mobile controls */
.mobile-controls {
  display: none;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 10px;
  margin-top: 15px;
  width: 100%;
  max-width: 300px;
}

.mobile-btn {
  background: var(--panel);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: var(--accent2);
  cursor: pointer;
  user-select: none;
}

.mobile-btn.rotate {
  grid-column: 2;
  grid-row: 1;
}

.mobile-btn.left {
  grid-column: 1;
  grid-row: 2;
}

.mobile-btn.down {
  grid-column: 2;
  grid-row: 2;
}

.mobile-btn.right {
  grid-column: 3;
  grid-row: 2;
}

.mobile-btn.hold {
  grid-column: 1;
  grid-row: 3;
}

.mobile-btn.drop {
  grid-column: 3;
  grid-row: 3;
}

@media (max-width: 768px) {
  .mobile-controls {
    display: grid;
  }
}

/* Stats display */
.stats {
  display: flex;
  justify-content: space-between;
  margin-top: 10px;
}

.stat-item {
  text-align: center;
}

.stat-value {
  font-size: 18px;
  font-weight: bold;
  color: var(--accent2);
}

.stat-label {
  font-size: 12px;
  color: #cdb9ff;
}

/* Sound controls */
.sound-controls {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 10px;
}

.sound-toggle {
  background: none;
  border: none;
  color: var(--accent2);
  cursor: pointer;
  font-size: 18px;
}

/* Explosion effects */
.explosion {
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  pointer-events: none;
  z-index: 10;
  animation: explode 0.5s ease-out forwards;
}

@keyframes explode {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  100% {
    transform: scale(2);
    opacity: 0;
  }
}

/* Line clear flash effect */
.line-flash {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.3);
  pointer-events: none;
  z-index: 5;
  animation: flash 0.3s ease-out forwards;
}

@keyframes flash {
  0% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Base Tetris">
  <div>
    <div class="header">
      <div class="brand">
        <img src="logo.png" width="50" class="logo-img">
        <div>
          <div class="title">Base Tetris <span class="small"> — <a href="https://dexscreener.com/base/0x2f263d261143d31eb9c583da6091f81c7be318d7c00131b299ba77c164b27af2" target="_blank" rel="noopener noreferrer" style="color:#FFFFFF; text-decoration:none; font-weight:bold;">0xDcaC95bCA18A7165f7D1644e885f0fE0A60af231</a></span></div>
          <div class="small">Socials: <a href="https://x.com/basetetris" target="_blank" rel="noopener noreferrer" style="color:#FFFFFF; text-decoration:none; font-weight:bold;">https://x.com/basetetris</a></div>
        </div>
      </div>
      <div class="controls">
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="resetBtn">Reset</button>
      </div>
    </div>

    <div class="panel play-area" role="main">
      <div class="canvas-wrap">
        <canvas id="board" width="224" height="704"></canvas>
      </div>

      <aside class="side" style="width:300px">
        <div class="info-card">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div>
              <div class="small">Score</div>
              <div id="score" style="font-size:20px;font-weight:900">0</div>
            </div>
            <div>
              <div class="small">Level</div>
              <div id="level" style="font-size:20px;font-weight:900">0</div>
            </div>
            <div>
              <div class="small">Lines</div>
              <div id="lines" style="font-size:20px;font-weight:900">0</div>
            </div>
          </div>
          
          <div class="stats">
            <div class="stat-item">
              <div class="stat-value" id="time">0s</div>
              <div class="stat-label">Time</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="pieces">0</div>
              <div class="stat-label">Pieces</div>
            </div>
          </div>
          
          <div class="sound-controls">
            <button class="sound-toggle" id="soundToggle">🔊</button>
            <div class="small">Sound On</div>
          </div>
          
          <div class="difficulty">
            <div class="difficulty-btn active" data-level="0">Easy</div>
            <div class="difficulty-btn" data-level="1">Normal</div>
            <div class="difficulty-btn" data-level="2">Hard</div>
          </div>
        </div>

        <div class="info-card">
          <div class="small">Next</div>
          <div id="nextPreview" class="preview-grid">
            <canvas class="preview-canvas" id="next0"></canvas>
            <canvas class="preview-canvas" id="next1"></canvas>
            <canvas class="preview-canvas" id="next2"></canvas>
          </div>
        </div>

        <div class="info-card">
          <div class="small">Hold</div>
          <canvas id="holdPreview" class="preview-canvas"></canvas>
        </div>

        <div class="info-card">
          <div class="small">Controls</div>
          <div style="margin-top:8px" class="legend">
            <div class="item"><kbd>←</kbd> Move</div>
            <div class="item"><kbd>→</kbd> Move</div>
            <div class="item"><kbd>↑</kbd> Rotate</div>
            <div class="item"><kbd>↓</kbd> Soft Drop</div>
            <div class="item"><kbd>Space</kbd> Hard Drop</div>
            <div class="item"><kbd>Tab</kbd> Hold</div>
          </div>
          
          <div class="instructions">
            <p>Clear lines to score points</p>
            <p>Level increases every 10 lines</p>
            <p>Game speeds up as level increases</p>
          </div>
        </div>

        <div class="info-card">
          <div class="small">Leaderboard (local)</div>
          <div id="leaderboard" style="margin-top:8px;max-height:200px;overflow:auto"></div>
        </div>
      </aside>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
      <div class="mobile-btn rotate">↻</div>
      <div class="mobile-btn left">←</div>
      <div class="mobile-btn down">↓</div>
      <div class="mobile-btn right">→</div>
      <div class="mobile-btn hold">Hold</div>
      <div class="mobile-btn drop">Drop</div>
    </div>

    <div class="footer">
      <div class="small">Theme: Vaporwave · Modern ruleset</div>
      <div class="small">v1.5</div>
    </div>
  </div>
</div>

<!-- Game Over Modal -->
<div class="modal" id="gameOverModal">
  <div class="modal-content">
    <h2>Game Over</h2>
    <p>Your score: <span id="finalScore">0</span></p>
    <input type="text" id="playerName" placeholder="Enter your name" maxlength="15">
    <div class="modal-buttons">
      <button class="btn" id="saveScoreBtn">Save Score</button>
      <button class="btn" id="cancelBtn">Cancel</button>
    </div>
  </div>
</div>

<script>
/* --------------------- Tetris Game Implementation ---------------------
 Features implemented per request:
 - Modern (hold, next 3, wall kicks basic SRS-ish)
 - Ghost piece
 - Hold queue
 - Next 3 preview
 - Vaporwave palette + neon-ish blocks
 - Keyboard-only controls
 - Local leaderboard (prompt username on game over)
 - Sound effects
 - Light explosion effects
*/

// Audio context and sound management
let audioContext;
let soundEnabled = true;

function initAudio() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
        console.log("Web Audio API is not supported in this browser");
        soundEnabled = false;
        document.getElementById('soundToggle').textContent = '🔇';
    }
}

function playSound(frequency, duration, type = 'sine', volume = 0.1) {
    if (!soundEnabled || !audioContext) return;
    
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = type;
    oscillator.frequency.value = frequency;
    
    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + duration);
}

// Sound effects
const sounds = {
    move: () => playSound(200, 0.05, 'square', 0.05),
    rotate: () => playSound(300, 0.08, 'sine', 0.08),
    softDrop: () => playSound(150, 0.1, 'sawtooth', 0.06),
    hardDrop: () => {
        playSound(80, 0.2, 'sine', 0.1);
        playSound(120, 0.15, 'square', 0.08);
    },
    lock: () => playSound(100, 0.15, 'sine', 0.08),
    lineClear: () => {
        playSound(523, 0.3, 'sine', 0.1);
        playSound(659, 0.25, 'sine', 0.08);
    },
    tetris: () => {
        playSound(1047, 0.5, 'sine', 0.15);
        playSound(1319, 0.4, 'sine', 0.1);
        playSound(1568, 0.3, 'sine', 0.08);
    },
    gameOver: () => {
        for (let i = 0; i < 8; i++) {
            setTimeout(() => {
                playSound(200 - i * 20, 0.2, 'sawtooth', 0.1);
            }, i * 100);
        }
    }
};

// Canvas & board config
const COLS = 10, ROWS = 24; // extra hidden rows
const VISIBLE_ROWS = 20;
const CELL = 28;
const boardCanvas = document.getElementById('board');
const ctx = boardCanvas.getContext('2d');
boardCanvas.width = COLS*CELL;
boardCanvas.height = VISIBLE_ROWS*CELL;

// preview canvases
const nextCanvases = [document.getElementById('next0'), document.getElementById('next1'), document.getElementById('next2')];
nextCanvases.forEach(c=>{ c.width=88; c.height=64; });
const holdCanvas = document.getElementById('holdPreview');
holdCanvas.width=88; holdCanvas.height=64;
const nctx = i=>nextCanvases[i].getContext('2d');
const hctx = holdCanvas.getContext('2d');

// UI elements
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const linesEl = document.getElementById('lines');
const timeEl = document.getElementById('time');
const piecesEl = document.getElementById('pieces');
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const leaderboardEl = document.getElementById('leaderboard');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreEl = document.getElementById('finalScore');
const playerNameInput = document.getElementById('playerName');
const saveScoreBtn = document.getElementById('saveScoreBtn');
const cancelBtn = document.getElementById('cancelBtn');
const soundToggle = document.getElementById('soundToggle');

// Colors map for tetromino
const COLORS = {
  'I': 'cI','O':'cO','T':'cT','S':'cS','Z':'cZ','J':'cJ','L':'cL'
};

// Tetromino shapes (rotation states)
const SHAPES = {
  'I': [[[0,1],[1,1],[2,1],[3,1]], [[2,0],[2,1],[2,2],[2,3]], [[0,2],[1,2],[2,2],[3,2]], [[1,0],[1,1],[1,2],[1,3]]],
  'O': [[[1,0],[2,0],[1,1],[2,1]]],
  'T': [[[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[2,1],[1,2]], [[1,0],[0,1],[1,1],[1,2]]],
  'S': [[[1,0],[2,0],[0,1],[1,1]], [[1,0],[1,1],[2,1],[2,2]], [[1,1],[2,1],[0,2],[1,2]], [[0,0],[0,1],[1,1],[1,2]]],
  'Z': [[[0,0],[1,0],[1,1],[2,1]], [[2,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[1,2],[2,2]], [[1,0],[0,1],[1,1],[0,2]]],
  'J': [[[0,0],[0,1],[1,1],[2,1]], [[1,0],[2,0],[1,1],[1,2]], [[0,1],[1,1],[2,1],[2,2]], [[1,0],[1,1],[0,2],[1,2]]],
  'L': [[[2,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[2,2]], [[0,1],[1,1],[2,1],[0,2]], [[0,0],[1,0],[1,1],[1,2]]]
};

// Utility: create empty board (ROWS x COLS)
function createBoard(){
  const b = [];
  for(let r=0;r<ROWS;r++){ b.push(new Array(COLS).fill(null)); }
  return b;
}

// draw a cell at board coordinates (r,c)
function drawCell(ctx, x, y, kind, ghost=false){
  const px = x*CELL, py = y*CELL;
  ctx.save();
  if(kind==null){
    ctx.fillStyle = '#05020a';
    ctx.fillRect(px,py,CELL,CELL);
  } else {
    // use classes mapping to gradient fills using canvas
    const g = ctx.createLinearGradient(px,py,px,py+CELL);
    switch(kind){
      case 'I': g.addColorStop(0,'#ffafff'); g.addColorStop(1,'#ff77ff'); break;
      case 'O': g.addColorStop(0,'#fff1a8'); g.addColorStop(1,'#ffd87a'); break;
      case 'T': g.addColorStop(0,'#c0b0ff'); g.addColorStop(1,'#8f77ff'); break;
      case 'S': g.addColorStop(0,'#a8fff7'); g.addColorStop(1,'#7be0ff'); break;
      case 'Z': g.addColorStop(0,'#ff9bb0'); g.addColorStop(1,'#ff6688'); break;
      case 'J': g.addColorStop(0,'#9be6ff'); g.addColorStop(1,'#4fc0ff'); break;
      case 'L': g.addColorStop(0,'#ffd6ff'); g.addColorStop(1,'#ff9bff'); break;
      default: g.addColorStop(0,'#666'); g.addColorStop(1,'#333');
    }
    ctx.fillStyle = g;
    ctx.fillRect(px+2,py+2,CELL-4,CELL-4);
    // outline
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px+2,py+2,CELL-4,CELL-4);
    if(ghost){ ctx.globalAlpha = 0.28; }
  }
  ctx.restore();
}

// game state
let board = createBoard();
let score = 0, level = 0, lines = 0, piecesPlaced = 0, gameTime = 0;
let current = null, currentPos = {x:3,y:0}, currentRot = 0;
let nextQueue = [];
let hold = null, canHold = true;
let dropInterval = 1000, dropTimer = null;
let running = false, paused = false;
let lastTick = 0;
let gameStartTime = 0;
let timeInterval = null;

// SRS-like wall kick tests (simplified)
const kicks = {
  'I': [[[0,0],[ -2,0],[1,0],[-2, -1],[1,2]],[ [0,0],[ -1,0],[2,0],[ -1,2],[2,-1] ],[[0,0],[2,0],[-1,0],[2,1],[-1,-2] ],[[0,0],[1,0],[-2,0],[1,-2],[-2,1]]],
  'other': [[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],[[0,0],[1,0],[1, -1],[0,2],[1,2]],[[0,0],[1,0],[1,1],[0,-2],[1,-2]],[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]]]
};

function randomPiece(){
  const bag = ['I','O','T','S','Z','J','L'];
  // use 7-bag
  if(!randomPiece._bag || randomPiece._bag.length===0){
    randomPiece._bag = shuffle(bag.slice());
  }
  return randomPiece._bag.pop();
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }

// spawn piece
function spawn(){
  current = nextQueue.shift() || randomPiece();
  // ensure queue length
  while(nextQueue.length<5) nextQueue.push(randomPiece());
  currentRot = 0;
  currentPos = {x:3,y:0};
  canHold = true;
  if(collides(currentPos.x,currentPos.y,current,currentRot)){
    // game over
    running=false;
    clearInterval(timeInterval);
    sounds.gameOver();
    gameOver();
  }
  updatePreviews();
}

// collision detection
function collides(px,py,type,rot){
  const states = SHAPES[type];
  const state = states[rot%states.length];
  for(const p of state){
    const x = px + p[0], y = py + p[1];
    if(x<0 || x>=COLS || y>=ROWS) return true;
    if(y>=0 && board[y][x]) return true;
  }
  return false;
}

// lock piece into board
function lock(){
  const state = SHAPES[current][currentRot%SHAPES[current].length];
  for(const p of state){
    const x = currentPos.x + p[0], y = currentPos.y + p[1];
    if(y>=0) board[y][x] = current;
  }
  piecesPlaced++;
  updateStats();
  sounds.lock();
  clearLines();
  spawn();
}

// clear lines with explosion effects
function clearLines(){
  let cleared=0;
  const rowsToClear = [];
  
  // Find complete rows
  for(let r=0;r<ROWS;r++){
    if(board[r].every(c=>c!==null)){
      rowsToClear.push(r);
    }
  }
  
  cleared = rowsToClear.length;
  
  if(cleared>0){
    lines += cleared;
    score += (cleared===1?100: cleared===2?300: cleared===3?500:800) * (level+1);
    level = Math.floor(lines/10);
    // speed up
    dropInterval = Math.max(100, 1000 - level*60);
    updateUI();
    
    // Add score animation
    scoreEl.classList.add('score-update');
    setTimeout(() => scoreEl.classList.remove('score-update'), 500);
    
    // Play sound effect
    if (cleared === 4) {
      sounds.tetris();
    } else {
      sounds.lineClear();
    }
    
    // Create explosion effects for cleared lines
    createExplosionEffects(rowsToClear);
    
    // Remove the lines after a brief delay to show the explosion
    setTimeout(() => {
      rowsToClear.forEach(r => {
        board.splice(r,1);
        board.unshift(new Array(COLS).fill(null));
      });
      draw();
    }, 300);
  }
}

// Create explosion effects for cleared lines
function createExplosionEffects(rows) {
  const canvasWrap = document.querySelector('.canvas-wrap');
  
  // Create a flash effect for the entire cleared area
  const flash = document.createElement('div');
  flash.className = 'line-flash';
  canvasWrap.appendChild(flash);
  
  // Remove flash after animation
  setTimeout(() => {
    if (flash.parentNode) {
      flash.parentNode.removeChild(flash);
    }
  }, 300);
  
  // Create explosion particles for each block in cleared rows
  rows.forEach(row => {
    for (let col = 0; col < COLS; col++) {
      // Calculate position relative to the visible board
      const visibleRow = row - (ROWS - VISIBLE_ROWS);
      if (visibleRow >= 0 && visibleRow < VISIBLE_ROWS) {
        createExplosion(col, visibleRow);
      }
    }
  });
}

// Create a single explosion at a specific cell
function createExplosion(col, row) {
  const canvasWrap = document.querySelector('.canvas-wrap');
  const explosion = document.createElement('div');
  explosion.className = 'explosion';
  
  // Set explosion color based on the block type (random for variety)
  const colors = ['#ff77ff', '#7be0ff', '#ffd87a', '#ff6688'];
  const color = colors[Math.floor(Math.random() * colors.length)];
  explosion.style.background = color;
  explosion.style.boxShadow = `0 0 10px ${color}`;
  
  // Position the explosion
  explosion.style.left = `${col * CELL + CELL/2 - 3}px`;
  explosion.style.top = `${row * CELL + CELL/2 - 3}px`;
  
  canvasWrap.appendChild(explosion);
  
  // Remove explosion after animation
  setTimeout(() => {
    if (explosion.parentNode) {
      explosion.parentNode.removeChild(explosion);
    }
  }, 500);
}

// update UI elements
function updateUI(){
  scoreEl.textContent = score;
  levelEl.textContent = level;
  linesEl.textContent = lines;
}

function updateStats() {
  piecesEl.textContent = piecesPlaced;
}

// rotate with kick
function rotate(dir){
  const oldRot = currentRot;
  const nRot = (currentRot + (dir>0?1: -1) + 100) % SHAPES[current].length;
  const table = current==='I'?kicks['I']:kicks['other'];
  for(const test of table[oldRot]){
    const nx = currentPos.x + test[0];
    const ny = currentPos.y + test[1];
    if(!collides(nx,ny,current,nRot)){
      currentPos.x = nx; currentPos.y = ny; currentRot = nRot;
      sounds.rotate();
      return true;
    }
  }
  // fallback no kick: if collides, do nothing
  return false;
}

// move left/right
function move(dx){
  if(!collides(currentPos.x+dx,currentPos.y,current,currentRot)){
    currentPos.x += dx;
    sounds.move();
  }
}

// soft drop
function softDrop(){
  if(!collides(currentPos.x,currentPos.y+1,current,currentRot)){
    currentPos.y += 1;
    score += 1;
    sounds.softDrop();
  } else {
    // lock
    lock();
  }
}

// hard drop
function hardDrop(){
  let drop = 0;
  while(!collides(currentPos.x,currentPos.y+1,current,currentRot)){
    currentPos.y +=1; drop++;
  }
  score += drop*2 + 10;
  sounds.hardDrop();
  lock();
}

// hold piece
function doHold(){
  if(!canHold) return;
  if(!hold){
    hold = current;
    spawn();
  } else {
    const tmp = hold;
    hold = current;
    current = tmp;
    currentPos = {x:3,y:0}; currentRot=0;
    if(collides(currentPos.x,currentPos.y,current,currentRot)){
      running=false; 
      sounds.gameOver();
      gameOver(); 
      return;
    }
  }
  canHold = false;
  updatePreviews();
}

// ghost piece calculation
function ghostPosition(){
  let gy = currentPos.y;
  while(!collides(currentPos.x,gy+1,current,currentRot)){
    gy++;
  }
  return gy;
}

// draw board (visible portion)
function draw(){
  // clear
  ctx.fillStyle = '#05020a'; ctx.fillRect(0,0,boardCanvas.width,boardCanvas.height);
  // draw grid + locked blocks
  for(let r=0;r<VISIBLE_ROWS;r++){
    for(let c=0;c<COLS;c++){
      const val = board[r+(ROWS-VISIBLE_ROWS)][c]; // show bottom rows
      drawCell(ctx,c,r,val);
    }
  }

  // draw ghost
  const gy = ghostPosition();
  const state = SHAPES[current][currentRot%SHAPES[current].length];
  ctx.save(); ctx.globalAlpha=0.28;
  for(const p of state){
    const x = currentPos.x + p[0];
    const y = currentPos.y + p[1] - (ROWS-VISIBLE_ROWS) + (gy - currentPos.y);
    if(y>=0 && y<VISIBLE_ROWS) drawCell(ctx,x,y,current,true);
  }
  ctx.restore();

  // draw current piece
  for(const p of state){
    const x = currentPos.x + p[0];
    const y = currentPos.y + p[1] - (ROWS-VISIBLE_ROWS);
    if(y>=0 && y<VISIBLE_ROWS) drawCell(ctx,x,y,current);
  }

  // grid lines subtle
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  for(let r=0;r<=VISIBLE_ROWS;r++){ ctx.beginPath(); ctx.moveTo(0,r*CELL); ctx.lineTo(COLS*CELL,r*CELL); ctx.stroke(); }
  for(let c=0;c<=COLS;c++){ ctx.beginPath(); ctx.moveTo(c*CELL,0); ctx.lineTo(c*CELL,VISIBLE_ROWS*CELL); ctx.stroke(); }
}

// draw small preview canvas for a piece
function drawPreview(pctx, type){
  pctx.fillStyle = '#05020a'; pctx.fillRect(0,0,88,64);
  if(!type) return;
  const state = SHAPES[type][0];
  // center offset
  const offsetX = 12, offsetY = 10;
  for(const cell of state){
    const x = offsetX + cell[0]*14;
    const y = offsetY + cell[1]*14;
    const g = pctx.createLinearGradient(x,y,x,y+14);
    switch(type){
      case 'I': g.addColorStop(0,'#ffafff'); g.addColorStop(1,'#ff77ff'); break;
      case 'O': g.addColorStop(0,'#fff1a8'); g.addColorStop(1,'#ffd87a'); break;
      case 'T': g.addColorStop(0,'#c0b0ff'); g.addColorStop(1,'#8f77ff'); break;
      case 'S': g.addColorStop(0,'#a8fff7'); g.addColorStop(1,'#7be0ff'); break;
      case 'Z': g.addColorStop(0,'#ff9bb0'); g.addColorStop(1,'#ff6688'); break;
      case 'J': g.addColorStop(0,'#9be6ff'); g.addColorStop(1,'#4fc0ff'); break;
      case 'L': g.addColorStop(0,'#ffd6ff'); g.addColorStop(1,'#ff9bff'); break;
    }
    pctx.fillStyle = g;
    pctx.fillRect(x+1,y+1,12,12);
    pctx.strokeStyle='rgba(0,0,0,0.2)'; pctx.strokeRect(x+1,y+1,12,12);
  }
}

// update next & hold previews
function updatePreviews(){
  for(let i=0;i<3;i++){
    const p = nextQueue[i];
    const c = nctx(i);
    drawPreview(c,p);
  }
  hctx.clearRect(0,0,88,64);
  drawPreview(hctx,hold);
}

// game loop tick (gravity)
function tick(now){
  if(!running || paused) return;
  if(!lastTick) lastTick = now;
  if(now - lastTick >= dropInterval){
    lastTick = now;
    if(!collides(currentPos.x,currentPos.y+1,current,currentRot)){
      currentPos.y +=1;
    } else {
      lock();
    }
    draw();
  }
  requestAnimationFrame(tick);
}

// controls
document.addEventListener('keydown',(e)=>{
  if(!running || paused) return;
  if(e.key === 'ArrowLeft'){ move(-1); draw(); e.preventDefault(); }
  else if(e.key === 'ArrowRight'){ move(1); draw(); e.preventDefault(); }
  else if(e.key === 'ArrowUp'){ rotate(1); draw(); e.preventDefault(); }
  else if(e.key === 'ArrowDown'){ softDrop(); draw(); e.preventDefault(); }
  else if(e.code === 'Space'){ hardDrop(); draw(); e.preventDefault(); }
  else if(e.key === 'Tab'){ doHold(); draw(); e.preventDefault(); }
});

// start / pause / reset buttons
startBtn.addEventListener('click',()=>{
  if(!running){ startGame(); }
});
pauseBtn.addEventListener('click',()=>{
  if(!running) return;
  paused = !paused;
  pauseBtn.textContent = paused? 'Resume':'Pause';
  if(!paused) requestAnimationFrame(tick);
});
resetBtn.addEventListener('click',()=>{
  if(confirm('Reset game?')) resetGame();
});

// Sound toggle
soundToggle.addEventListener('click', () => {
  soundEnabled = !soundEnabled;
  soundToggle.textContent = soundEnabled ? '🔊' : '🔇';
});

// start game
function startGame(){
  board = createBoard();
  score = 0; level=0; lines=0; piecesPlaced=0; gameTime=0;
  nextQueue = [];
  while(nextQueue.length<5) nextQueue.push(randomPiece());
  hold = null; canHold=true;
  spawn();
  running=true; paused=false; lastTick=0;
  dropInterval = 1000;
  gameStartTime = Date.now();
  
  // Start timer
  clearInterval(timeInterval);
  timeInterval = setInterval(() => {
    if (running && !paused) {
      gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
      timeEl.textContent = gameTime + 's';
    }
  }, 1000);
  
  updateUI(); updateStats(); updatePreviews(); draw();
  requestAnimationFrame(tick);
}

// reset full
function resetGame(){
  running=false; paused=false;
  board = createBoard(); score=0; level=0; lines=0; piecesPlaced=0; gameTime=0;
  clearInterval(timeInterval);
  updateUI(); updateStats(); draw(); updatePreviews();
}

// game over & leaderboard
function gameOver(){
  draw();
  finalScoreEl.textContent = score;
  playerNameInput.value = '';
  gameOverModal.style.display = 'flex';
}

// leaderboard local storage
const LB_KEY = 'vapor_tetris_lb_v1';
function loadLB(){ try{ return JSON.parse(localStorage.getItem(LB_KEY)||'[]'); }catch(e){ return []; } }
function saveScore(name,scoreVal){
  const lb = loadLB();
  lb.push({name,score:scoreVal,date:new Date().toISOString()});
  lb.sort((a,b)=>b.score-a.score);
  if(lb.length>10) lb.length=10;
  localStorage.setItem(LB_KEY, JSON.stringify(lb));
}
function renderLeaderboard(){
  const lb = loadLB();
  leaderboardEl.innerHTML='';
  if(lb.length===0){ leaderboardEl.innerHTML='<div class="small">No scores yet</div>'; return; }
  lb.forEach((it,idx)=>{
    const div = document.createElement('div'); div.className='lb-row';
    div.innerHTML = `<div>#${idx+1} ${it.name}</div><div>${it.score}</div>`;
    leaderboardEl.appendChild(div);
  });
}

// Modal handlers
saveScoreBtn.addEventListener('click', () => {
  const name = playerNameInput.value.trim() || 'Player';
  saveScore(name, score);
  renderLeaderboard();
  gameOverModal.style.display = 'none';
});

cancelBtn.addEventListener('click', () => {
  gameOverModal.style.display = 'none';
});

// Difficulty selector
document.querySelectorAll('.difficulty-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    
    // Adjust starting difficulty
    const difficulty = parseInt(btn.dataset.level);
    switch(difficulty) {
      case 0: dropInterval = 1000; break; // Easy
      case 1: dropInterval = 800; break;  // Normal
      case 2: dropInterval = 600; break;  // Hard
    }
  });
});

// Mobile controls
document.querySelectorAll('.mobile-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    if (!running || paused) return;
    
    const action = btn.textContent;
    switch(action) {
      case '↻': rotate(1); break;
      case '←': move(-1); break;
      case '→': move(1); break;
      case '↓': softDrop(); break;
      case 'Hold': doHold(); break;
      case 'Drop': hardDrop(); break;
    }
    draw();
  });
});

// init
initAudio();
renderLeaderboard();
draw(); updatePreviews();

// auto start minimized warmup: draw initial state
</script>
</body>
</html>
